// Generated by CoffeeScript 1.7.1
(function() {
  (function(root, factory) {
    if (typeof define === "function" && define.amd) {
      return define(["phoenix"], factory);
    } else if (typeof exports === "object") {
      return factory(exports);
    } else {
      return factory((root.Phoenix = {}));
    }
  })(this, function(exports) {
    exports.Channel = (function() {
      Channel.prototype.bindings = null;

      function Channel(channel, topic, message, callback, socket) {
        this.channel = channel;
        this.topic = topic;
        this.message = message;
        this.callback = callback;
        this.socket = socket;
        this.reset();
      }

      Channel.prototype.reset = function() {
        return this.bindings = [];
      };

      Channel.prototype.on = function(event, callback) {
        return this.bindings.push({
          event: event,
          callback: callback
        });
      };

      Channel.prototype.isMember = function(channel, topic) {
        return this.channel === channel && this.topic === topic;
      };

      Channel.prototype.off = function(event) {
        var bind;
        return this.bindings = (function() {
          var _i, _len, _ref, _results;
          _ref = this.bindings;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            bind = _ref[_i];
            if (bind.event !== event) {
              _results.push(bind);
            }
          }
          return _results;
        }).call(this);
      };

      Channel.prototype.trigger = function(triggerEvent, msg) {
        var callback, event, _i, _len, _ref, _ref1, _results;
        _ref = this.bindings;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], event = _ref1.event, callback = _ref1.callback;
          if (event === triggerEvent) {
            _results.push(callback(msg));
          }
        }
        return _results;
      };

      Channel.prototype.send = function(event, message) {
        return this.socket.send({
          channel: this.channel,
          topic: this.topic,
          event: event,
          message: message
        });
      };

      Channel.prototype.leave = function(message) {
        if (message == null) {
          message = {};
        }
        this.socket.leave(this.channel, this.topic, message);
        return this.reset();
      };

      return Channel;

    })();
    exports.Socket = (function() {
      Socket.prototype.conn = null;

      Socket.prototype.endPoint = null;

      Socket.prototype.channels = null;

      Socket.prototype.sendBuffer = null;

      Socket.prototype.sendBufferTimer = null;

      Socket.prototype.flushEveryMs = 50;

      Socket.prototype.reconnectTimer = null;

      Socket.prototype.reconnectAfterMs = 5000;

      Socket.prototype.heartbeatIntervalMs = 30000;

      Socket.prototype.stateChangeCallbacks = null;

      function Socket(endPoint, opts) {
        var _ref;
        if (opts == null) {
          opts = {};
        }
        this.heartbeatIntervalMs = (_ref = opts.heartbeatIntervalMs) != null ? _ref : this.heartbeatIntervalMs;
        this.endPoint = this.expandEndpoint(endPoint);
        this.channels = [];
        this.sendBuffer = [];
        this.stateChangeCallbacks = {
          open: [],
          close: [],
          error: []
        };
        this.resetBufferTimer();
        this.reconnect();
      }

      Socket.prototype.protocol = function() {
        if (location.protocol.match(/^https/)) {
          return "wss";
        } else {
          return "ws";
        }
      };

      Socket.prototype.expandEndpoint = function(endPoint) {
        if (endPoint.charAt(0) !== "/") {
          return endPoint;
        }
        if (endPoint.charAt(1) === "/") {
          return "" + (this.protocol()) + ":" + endPoint;
        }
        return "" + (this.protocol()) + "://" + location.host + endPoint;
      };

      Socket.prototype.close = function(callback, code, reason) {
        if (this.conn != null) {
          this.conn.onclose = (function(_this) {
            return function() {};
          })(this);
          if (code != null) {
            this.conn.close(code, reason != null ? reason : "");
          } else {
            this.conn.close();
          }
          this.conn = null;
        }
        return typeof callback === "function" ? callback() : void 0;
      };

      Socket.prototype.reconnect = function() {
        return this.close((function(_this) {
          return function() {
            _this.conn = new WebSocket(_this.endPoint);
            _this.conn.onopen = function() {
              return _this.onConnOpen();
            };
            _this.conn.onerror = function(error) {
              return _this.onConnError(error);
            };
            _this.conn.onmessage = function(event) {
              return _this.onMessage(event);
            };
            return _this.conn.onclose = function(event) {
              return _this.onConnClose(event);
            };
          };
        })(this));
      };

      Socket.prototype.resetBufferTimer = function() {
        clearTimeout(this.sendBufferTimer);
        return this.sendBufferTimer = setTimeout(((function(_this) {
          return function() {
            return _this.flushSendBuffer();
          };
        })(this)), this.flushEveryMs);
      };

      Socket.prototype.onOpen = function(callback) {
        if (callback) {
          return this.stateChangeCallbacks.open.push(callback);
        }
      };

      Socket.prototype.onClose = function(callback) {
        if (callback) {
          return this.stateChangeCallbacks.close.push(callback);
        }
      };

      Socket.prototype.onError = function(callback) {
        if (callback) {
          return this.stateChangeCallbacks.error.push(callback);
        }
      };

      Socket.prototype.onConnOpen = function() {
        var callback, _i, _len, _ref, _results;
        clearInterval(this.reconnectTimer);
        this.heartbeatTimer = setInterval(((function(_this) {
          return function() {
            return _this.sendHeartbeat();
          };
        })(this)), this.heartbeatIntervalMs);
        this.rejoinAll();
        _ref = this.stateChangeCallbacks.open;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          callback = _ref[_i];
          _results.push(callback());
        }
        return _results;
      };

      Socket.prototype.onConnClose = function(event) {
        var callback, _i, _len, _ref, _results;
        if (typeof console.log === "function") {
          // console.log("WS close: ", event);
        }
        clearInterval(this.reconnectTimer);
        clearInterval(this.heartbeatTimer);
        this.reconnectTimer = setInterval(((function(_this) {
          return function() {
            return _this.reconnect();
          };
        })(this)), this.reconnectAfterMs);
        _ref = this.stateChangeCallbacks.close;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          callback = _ref[_i];
          _results.push(callback(event));
        }
        return _results;
      };

      Socket.prototype.onConnError = function(error) {
        var callback, _i, _len, _ref, _results;
        if (typeof console.log === "function") {
          // console.log("WS error: ", error);
        }
        _ref = this.stateChangeCallbacks.error;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          callback = _ref[_i];
          _results.push(callback(error));
        }
        return _results;
      };

      Socket.prototype.connectionState = function() {
        var _ref;
        switch ((_ref = this.conn) != null ? _ref.readyState : void 0) {
          case WebSocket.CONNECTING:
            return "connecting";
          case WebSocket.OPEN:
            return "open";
          case WebSocket.CLOSING:
            return "closing";
          case WebSocket.CLOSED:
          case null:
            return "closed";
        }
      };

      Socket.prototype.isConnected = function() {
        return this.connectionState() === "open";
      };

      Socket.prototype.rejoinAll = function() {
        var chan, _i, _len, _ref, _results;
        _ref = this.channels;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          chan = _ref[_i];
          _results.push(this.rejoin(chan));
        }
        return _results;
      };

      Socket.prototype.rejoin = function(chan) {
        var channel, message, topic;
        chan.reset();
        channel = chan.channel, topic = chan.topic, message = chan.message;
        this.send({
          channel: channel,
          topic: topic,
          event: "join",
          message: message
        });
        return chan.callback(chan);
      };

      Socket.prototype.join = function(channel, topic, message, callback) {
        var chan;
        chan = new exports.Channel(channel, topic, message, callback, this);
        this.channels.push(chan);
        if (this.isConnected()) {
          return this.rejoin(chan);
        }
      };

      Socket.prototype.leave = function(channel, topic, message) {
        var c;
        if (message == null) {
          message = {};
        }
        this.send({
          channel: channel,
          topic: topic,
          event: "leave",
          message: message
        });
        return this.channels = (function() {
          var _i, _len, _ref, _results;
          _ref = this.channels;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            if (!(c.isMember(channel, topic))) {
              _results.push(c);
            }
          }
          return _results;
        }).call(this);
      };

      Socket.prototype.send = function(data) {
        var callback;
        callback = (function(_this) {
          return function() {
            return _this.conn.send(JSON.stringify(data));
          };
        })(this);
        if (this.isConnected()) {
          return callback();
        } else {
          return this.sendBuffer.push(callback);
        }
      };

      Socket.prototype.sendHeartbeat = function() {
        return this.send({
          channel: "phoenix",
          topic: "conn",
          event: "heartbeat",
          message: {}
        });
      };

      Socket.prototype.flushSendBuffer = function() {
        var callback, _i, _len, _ref;
        if (this.isConnected() && this.sendBuffer.length > 0) {
          _ref = this.sendBuffer;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            callback = _ref[_i];
            callback();
          }
          this.sendBuffer = [];
        }
        return this.resetBufferTimer();
      };

      Socket.prototype.onMessage = function(rawMessage) {
        var chan, channel, event, message, topic, _i, _len, _ref, _ref1, _results;
        if (typeof console.log === "function") {
          // console.log("message received: ", rawMessage);
        }
        _ref = JSON.parse(rawMessage.data), channel = _ref.channel, topic = _ref.topic, event = _ref.event, message = _ref.message;
        _ref1 = this.channels;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          chan = _ref1[_i];
          if (chan.isMember(channel, topic)) {
            _results.push(chan.trigger(event, message));
          }
        }
        return _results;
      };

      return Socket;

    })();
    return exports;
  });

}).call(this);
